## シリアル

### この文書は
qrpcのシリアルについて、必要性や具体的な実装を記したものです

### 動機
qrpcの内部オブジェクト、特にstream/connはユーザープログラムからの操作対象(特に送信)である。これらがさすメモリ領域はプログラムの内部処理で解放されることがある。
stream/connへの操作のために内部オブジェクトへのポインタを様々な言語に公開したい。が、上記の理由から、公開されたポインタがすでに解放されていたり、さらに複雑なケースではABA問題のような形で、アロケートされているが、別のstream/connを指している可能性もある。これらは複雑なバグの原因となる。これを防止したい。

### 要件
C APIの呼び出し時に以下のようなことをチェックできるようにしたい
- 渡された、呼び出し側に公開された内部オブジェクトへのポインタが有効であること
- 渡された、呼び出し側に公開された内部オブジェクトが指す対象が公開されたタイミングから変更されていない

### 実装
1. 公開される内部オブジェクトはallocator.hに定義されているAllocatorクラスで割り当てられる。これにより、一度内部オブジェクトを指す領域となったメモリの一部が中途半端に他の内部オブジェクトに割り当てられることがない。

2. C API側に公開するデータ構造は以下のようになる
```
struct handle_t {
  void *p;
  uint64_t s;
}
```

3. pがqrpcの内部オブジェクトへのポインタ。pに割り当て可能なオブジェクトは自分のメモリ領域でserialという64bit値を保持しており、handleに変換するための関数ToHandle()
を持っている。ToHandle()では呼ばれたタイミングで、自身を指すポインタ(this)と、thisが持っているシリアルの組みでhandle_tを生成して呼び出し側に返す。

4. pが解放されるとserialは０にセットされる。pが割り当てられるとserialはqrpc全体でユニークな値(eg. インクリメントされる整数)が設定される。

5. handle_tを受け取って呼び出されるqrpcのCAPIは以下のようなチェックを行う。1.よりpは常に完全な内部オブジェクトを指すため、pを内部オブジェクトにキャストして、シリアルを保存しているオフセットを参照した値(pから取得したシリアルと呼ぶ)は、常にシリアルを指している領域となる。つまり何かゴミを指す領域を参照して不正な値のシリアルを読んでしまうことがない前提である。
  - pから取得したシリアルが０ではない -> 解放されていない
  - pから取得したシリアルとhandle_t::sが等しい -> 解放されたあと、別のオブジェクトのために確保されていない

### 追加のアイデア
- serialに他の情報を埋め込むことはなんらかの使い道があるかもしれない。
  - たとえばスレッドIDを埋め込むと、カレントスレッドと同じ時だけすぐに処理を行い、そうでなければ、他のスレッドのキューに積んで処理させる、といったことが軽量な比較だけで行えるようになる