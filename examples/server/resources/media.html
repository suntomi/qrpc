<!doctype html>
<html>
  <head>
    <title>WebRTC with QRPC media</title>
    <style>
      /* CSSでビデオ要素の幅と高さをビューポートの幅と高さのパーセンテージで設定 */
      .media-list-container {
        display: flex;
        justify-content: space-between;
      }
      .media-container {
        position: relative;
        width: 50vw; /* ビューポートの幅の50% */
        display: flex; /* 子要素の高さに合わせる */        
      }
      .overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
      }
      .overlay .icon {
        font-size: 48px;
        color: white;
        display: flex;
      }
      .overlay .icon img {
        width: 12.5vw;
        height: auto;
      }
      .audio-switch {
        width: 5vw;
        height: 5vw;
        position: absolute;
        bottom: 0.5vh;
        right: 0.5vw;
        z-index: 1;
      }
      .audio-switch img {
        width: 100%;
        height: auto;
      }
      .label {
        /* このクラスの下のテキストを白色にする */
        color: white;
        position: absolute;
        bottom: 0;
        left: 0;
        /* background-color: rgba(0, 0, 0, 0.5); */
        /* 黒の縁取りをつける */
        text-shadow: 1px 1px 1px black;
        padding: 0.2em;
        box-sizing: border-box;
      }
      video {
        width: 100%;
        height: auto;
      }
    </style>    
  </head>
  <body>
    <div id="cname"></div>
    <div id="subscribe">
      <input type="text" id="idedit" placeholder="input connection id of other peer"/>
      <input type="text" id="lpath_sub" placeholder="input local path" value="webcam"/>
      <button id="sub">subscribe</button>
    </div>
    <div id="publish">
      <input type="text" id="lpath_pub" placeholder="input local path" value="webcam2"/>
      <button id="pub">publish</button>
    </div>
    <div>published tracks</div>
    <div id="pubsList" class="media-list-container"></div>
    <div>subscribed tracks</div>
    <div id="subsList" class="media-list-container"></div>
    <button id="reconnect">reconnect</button>

    <script src="http://localhost:8888/client.js"></script>
    <script>
      const pubsList = document.getElementById('pubsList');
      const subsList = document.getElementById('subsList');
      const pub = document.getElementById('pub');
      const sub = document.getElementById('sub');
      const reconnect = document.getElementById('reconnect');
      const pausedElements = {};
      createOverlayElement = (manually) => {
        const overlay = document.createElement('div');
        overlay.className = 'overlay';
        const icon = document.createElement('div');
        icon.className = 'icon';
        if (manually) {
          icon.innerHTML = '&#9654;';
        } else {
          const img = document.createElement('img');
          img.src = './loading.gif'; // ローディングGIFのパスを指定
          img.alt = 'Loading...';
          icon.appendChild(img);          
        }
        overlay.appendChild(icon);
        return overlay;
      }
      createAudioSwitchElement = (track) => {
        const audioSwitch = document.createElement('div');
        const mediaControlHandler = createMediaControlHandler(track);
        audioSwitch.className = 'audio-switch';
        const img = document.createElement('img');
        img.src = './audio-on.svg';
        img.alt = 'Loading...';
        audioSwitch.appendChild(img);
        audioSwitch.addEventListener('click', async (event) => {
          console.log("audio switch", track.path, pausedElements[track.path] ? "paused" : "active");
          event.stopPropagation(); // if it puts after await, not effective. I guess the callback is regarded as finished when await is happen.
          await mediaControlHandler(event);
          const img = document.createElement('img');
          img.src = pausedElements[track.path] ? './audio-off.svg' : './audio-on.svg';
          img.alt = 'Loading...';
          audioSwitch.replaceChild(img, audioSwitch.firstChild);
        });
        return audioSwitch;
      }
      createMediaHandler = (dom) => {
        return {
          onopen: (track)=>{
            console.log("media open", track.stream.id, track.id);
            let mediaElement = document.getElementById(`${track.kind}-${track.id}`);
            if (!mediaElement) {
              createMediaElement(track, dom);
            }
            // track.raw.onmute/onunmute behaviour is unstable for browsers,
            // use our callback onpause/onresume instead.
          },
          onclose: (track)=>{
            console.log("media close", track.stream.id, track.kind);
            const container_id = `media-${track.directory.replace(/\//g, '-')}`;
            document.getElementById(container_id)?.remove();
          },
          onpause: (track, manually)=>{
            console.log("media pause", track.stream.id, track.kind, manually);
            if (track.kind !== "video") { return; }
            const container_id = `media-${track.directory.replace(/\//g, '-')}`;
            const container = document.getElementById(container_id);
            const overlays = container?.getElementsByClassName('overlay');
            if (overlays?.length == 0) {
              document.getElementById(container_id).appendChild(createOverlayElement(manually));
            }
          },
          onresume: (track, manually)=>{
            console.log("media resume", track.stream.id, track.kind, manually);
            if (track.kind !== "video") { return; }
            const container_id = `media-${track.directory.replace(/\//g, '-')}`;
            const container = document.getElementById(container_id);
            const overlays = container?.getElementsByClassName('overlay');
            if (overlays?.length > 0) {
              container.removeChild(overlays[0]);
            }
          },
        };
      }
      createMediaControlHandler = (t) => {
        return async (event) => {
          const path = t.path;
          const paused = pausedElements[path];
          try {
            if (paused) {
              console.log("resume", path);
              await c.resumeMedia(path);
              delete pausedElements[path];
            } else {
              console.log("pause", path);
              await c.pauseMedia(path);
              pausedElements[path] = true;
            }
          } catch (e) {
            console.error(e);
          }
        }
      }
      createMediaElement = (t, dom) => {
        console.log("createMediaElement", t.path);
        const container_id = `media-${t.directory.replace(/\//g, '-')}`;
        let container = document.getElementById(container_id);
        if (!container) {
          container = document.createElement('div');
          container.className = 'media-container';
          container.id = container_id;
          // label text element
          const label = document.createElement('div');
          label.className = 'label';
          label.textContent = t.directory;
          container.appendChild(label);
          dom.appendChild(container);
        }
        let mediaElement = document.getElementById(`${t.kind}-${t.id}`);
        if (!mediaElement) {
          mediaElement = document.createElement(t.kind);
          mediaElement.id = `${t.kind}-${t.id}`;
          mediaElement.autoplay = true;
          container.appendChild(mediaElement);
          if (t.kind === 'video') {
            // attach pause/resume handler for entire container click event
            container.addEventListener('click', createMediaControlHandler(t));
          } else if (t.kind === 'audio') {
            // attach pause/resume handler for audio switch elemnt click event
            container.appendChild(createAudioSwitchElement(t));
          }
        }
        mediaElement.srcObject = t.stream;
        return container;
      }
      openMedia = async (path, handler) => {
        await c.openMedia(path, Object.assign({}, handler, {
          stream: await navigator.mediaDevices.getUserMedia({
            video: {width: {ideal: 1280}, height: {ideal: 720}},
            audio: true
          }), 
          encodings: [
            // 5Mbps ?
            {rid: 'h1', maxBitrate: 5000000, active: true, scaleResolutionDownBy: 1.0},
            // 1Mbps ?
            {rid: 'm1', maxBitrate: 1000000, active: true, scaleResolutionDownBy: 2.0},
            // 100kbps ?
            {rid: 'l1', maxBitrate: 500000, active: true, scaleResolutionDownBy: 4.0}
          ],
        }));        
      }
      onPublish = async (event) => {
        const lpath = document.getElementById('lpath_pub').value;
        console.log(`publish: input path = ${lpath}`);
        await openMedia(lpath, createMediaHandler(pubsList, true));
      }
      onSubscribe = async (event) => {
        const id = document.getElementById('idedit').value;
        const lpath = document.getElementById('lpath_sub').value;
        const path = `${id}/${lpath}`;
        console.log(`subscribe: input path = ${path}`);
        await c.viewMedia(path, createMediaHandler(subsList));
      }
      onReconnect = (event) => {
        console.log("shutdown by UI");
        c.close();
      }
      setupUI = (c) => {
        let idElement = document.getElementById("cname");
        if (idElement) {
          idElement.innerText = c.cname;
        }
        pub.addEventListener('click', onPublish);
        sub.addEventListener('click', onSubscribe);
        reconnect.addEventListener('click', onReconnect);
      }
      cleanupUI = (c) => {
        pub.removeEventListener('click', onPublish);
        sub.removeEventListener('click', onSubscribe);
        reconnect.removeEventListener('click', onReconnect);
      }
      //Create client
      const url = "http://localhost:8888/qrpc";
      const c = new QRPClient(url);
      const context = {};
      const MAX_RECONNECT = 1;
      let closed = 0;
      c.onopen = async () => {
        console.log("client onopen called");
        setupUI(c);
        await openMedia("webcam", createMediaHandler(pubsList, true));
        return context;
      };
      c.onclose = () => {
        console.log("client onclose called", closed);
        cleanupUI(c);
        if (closed < MAX_RECONNECT) {
          closed++;
          return 2000 * 1000 * 1000;
        } else {
          return;
        }
      };
      c.connect();
    </script>
  </body>
</html>
