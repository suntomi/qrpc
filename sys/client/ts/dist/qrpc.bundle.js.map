{
  "version": 3,
  "sources": ["../src/index.ts", "../src/types.ts", "../src/track.ts", "../src/media.ts", "../src/client.ts"],
  "sourcesContent": ["// Main exports for the QRPC TypeScript client library\n\nexport { QRPClient } from './client.js';\nexport { QRPCTrack } from './track.js';\nexport { QRPCMedia } from './media.js';\nexport { \n  QRPCStreamHandler, \n  QRPCStreamParams,\n  QRPCMediaInitOptions,\n  QRPCMediaSenderHandler,\n  QRPCMediaSenderParams,\n  QRPCMediaReceiverHandler,\n  QRPCMediaReceiverParams,\n} from './types.js';\n", "// Type definitions for QRPC client\nimport { QRPCTrack } from './track.js';\n\nexport type Exclude<T,U> = T extends U ? never : T;\nexport type MayAwaitable<T> = Exclude<any, Promise<any>> | Promise<T>;\n\nexport function promisify<T>(a: MayAwaitable<T>): Promise<T> {\n  if (a instanceof Promise) {\n    return a as Promise<T>;\n  } else {\n    return Promise.resolve(a);\n  }\n}\n\nexport interface QRPCBaseMediaHandler {\n  onopen: (track: QRPCTrack) => MayAwaitable<false | null>;\n  onclose: (track: QRPCTrack) => MayAwaitable<void>;\n  onpause?: (track: QRPCTrack, reason: string) => MayAwaitable<number>;\n  onresume?: (track: QRPCTrack, reason: string) => MayAwaitable<void>;\n}\nexport type QRPCMediaSenderHandler = QRPCBaseMediaHandler & {\n  onupdate?: (track: QRPCTrack) => MayAwaitable<void>;\n}\nexport type QRPCMediaReceiverHandler = QRPCBaseMediaHandler\nexport interface QRPCTrackInitOptions {\n  pause?: boolean;\n}\nexport interface QRPCMediaInitOptions {\n  sync?: boolean;\n  audio?: QRPCTrackInitOptions;\n  video?: QRPCTrackInitOptions;\n}\nexport type QRPCMediaSenderParams = QRPCMediaSenderHandler & {\n  stream: MediaStream;\n  encodings: Encoding[];\n  initOptions?: QRPCMediaInitOptions;\n}\nexport type QRPCMediaReceiverParams = QRPCMediaReceiverHandler & {\n  initOptions?: QRPCMediaInitOptions;\n}\n\nexport interface QRPCStreamHandler {\n  onopen?: (stream: RTCDataChannel, event: Event) => MayAwaitable<any>;\n  onclose?: (stream: RTCDataChannel, event: Event) => MayAwaitable<void>;\n  onerror?: (stream: RTCDataChannel, event: Event) => MayAwaitable<void>;\n  onmessage: (stream: RTCDataChannel, event: MessageEvent) => MayAwaitable<void>;\n}\n\nexport type QRPCStreamParams = QRPCStreamHandler & RTCDataChannelInit & {\n  publish?: boolean;\n}\n\nexport interface QRPCSyscallArgs {\n  [key: string]: any;\n}\n\nexport interface QRPCMidMediaPathMap {\n  [mid: string]: string;\n}\n\nexport interface StatusMap {\n  [path: string]: {\n    pausedReasons?: string[];\n  };\n}\n\nexport interface SyscallMessage {\n  fn: string;\n  args?: QRPCSyscallArgs;\n  msgid?: number;\n}\n\nexport interface QRPCPromiseCallbacks {\n  resolve: (value?: any) => void;\n  reject: (reason?: any) => void;\n}\n\nexport interface TrackUpdate {\n  stream: MediaStream;\n  track: MediaStreamTrack;\n}\n\nexport interface Encoding {\n  rid?: string;\n  scalabilityMode?: string;\n  maxBitrate?: number;\n  [key: string]: any;\n}\n", "import {\n  QRPCMediaSenderHandler, QRPCMediaReceiverHandler,\n  TrackUpdate, QRPCMidMediaPathMap, Encoding, MayAwaitable, promisify\n} from './types.js';\nimport { QRPCMedia } from './media.js';\n\nexport class QRPCTrack {\n  static readonly DEFAULT_TRACK_RECONNECTION_WAIT_MS = 5000;\n  static readonly PAUSE_REASON = {\n    remote_close: \"remote_close\",\n    local_op: \"local_op\",\n    remote_op: \"remote_op\",\n  } as const;\n\n  public readonly path: string;\n  public readonly media: QRPCMedia;\n  public stream: MediaStream | null;\n  public track: MediaStreamTrack | null;\n  public readonly encodings: Encoding[];\n  public readonly onopen: (track: QRPCTrack) => MayAwaitable<false | null | void>;\n  public readonly onclose: (track: QRPCTrack) => MayAwaitable<void>;\n  public readonly onpause?: (track: QRPCTrack, reason: string) => MayAwaitable<number | void | false | null>;\n  public readonly onresume?: (track: QRPCTrack, reason: string) => MayAwaitable<void>;\n  public readonly onupdate?: (track: QRPCTrack) => MayAwaitable<void>;\n  public opened: boolean = false;\n  public pausedReasons: string[] = [];\n  public transceiver: RTCRtpTransceiver | null = null;\n  public ssrc?: string;\n\n  static path(canonical_path: string, kind: string): string {\n    return canonical_path + kind;\n  }\n\n  constructor(\n    path: string,\n    media: QRPCMedia,\n    stream: MediaStream | null,\n    track: MediaStreamTrack | null,\n    encodings: Encoding[],\n    options: QRPCMediaSenderHandler | QRPCMediaReceiverHandler\n  ) {\n    this.path = path;\n    this.media = media;\n    this.media.addTrack(this);\n    this.stream = stream;\n    this.track = track;\n    this.encodings = encodings;\n    this.onopen = options.onopen;\n    this.onclose = options.onclose;\n    this.onpause = options.onpause || (() => {});\n    this.onresume = options.onresume || (() => {});\n    this.onupdate = (options as QRPCMediaSenderHandler).onupdate || (() => {});\n  }\n\n  get id(): string {\n    return this.track?.id || '';\n  }\n\n  get kind(): string {\n    const parsed = this.path.split(\"/\");\n    return parsed[parsed.length - 1];\n  }\n\n  get raw(): MediaStreamTrack | null {\n    return this.track;\n  }\n\n  get cname(): string {\n    const parsed = this.path.split(\"/\");\n    if (!this.isReceiver) {\n      throw new Error(\"cname is only for receiver track\");\n    }\n    return parsed[0];\n  }\n\n  get directory(): string {\n    return this.path.split(\"/\").slice(0, -1).join(\"/\");\n  }\n\n  get mid(): string | null {\n    return this.transceiver?.mid || null;\n  }\n\n  get active(): boolean {\n    return this.track != null;\n  }\n\n  get paused(): boolean {\n    return this.pausedReasons.length > 0;\n  }\n\n  get direction(): string {\n    return this.media.direction;\n  }\n\n  get isReceiver(): boolean {\n    return this.media.isReceiver;\n  }\n\n  pausedBy(reason: string): boolean {\n    return this.pausedReasons.indexOf(reason) >= 0;\n  }\n\n  pause(reason: string, noCallback?: boolean): Promise<number> {\n    const i = this.pausedReasons.indexOf(reason);\n    if (i < 0) {\n      this.pausedReasons.push(reason);\n    }\n    return promisify(!noCallback && this.onpause && this.onpause(this, reason));\n  }\n\n  resume(reason: string, noCallback?: boolean): Promise<void> {\n    const i = this.pausedReasons.indexOf(reason);\n    if (i >= 0) {\n      this.pausedReasons.splice(i, 1);\n      return promisify(!noCallback && this.onresume && this.onresume(this, reason));\n    }\n    return Promise.resolve();\n  }\n\n  update(update: TrackUpdate): Promise<void> {\n    if (!this.transceiver) {\n      throw new Error(\"track is not started\");\n    }\n    this.stream = update.stream;\n    this.transceiver.sender.replaceTrack(update.track);\n    this.track?.stop();\n    this.track = update.track;\n    return promisify(this.onupdate?.(this));\n  }\n\n  async open(pc: RTCPeerConnection, midMediaPathMap?: QRPCMidMediaPathMap): Promise<void> {\n    if (this.direction !== \"send\" || this.track == null) {\n      throw new Error(\"open is only needed for send tracks\");\n    }\n\n    if (midMediaPathMap) {\n      // want to put tracks to actual peer connection (not for generating localOffer for producing)\n      let transceiver: RTCRtpTransceiver | undefined;\n      \n      // find transceiver for this track by comparing logical path of the track and path decided by server mid\n      for (const t of pc.getTransceivers()) {\n        if (!t.sender) {\n          console.log(\"ignore receiver transceiver\", t.sender);\n          continue;\n        }\n        // in here, pc.setRemoteDescription is already called, so mid is decided by server remote offer\n        // also midMediaPathMap is updated by syscall (\"produce\") or whip API call (in QRPClient.#handshake)\n        const path = midMediaPathMap[t.mid!];\n        if (!path) {\n          console.log(\"no path for mid:\", t.mid, midMediaPathMap);\n          continue;\n        }\n        if (path == this.path) {\n          transceiver = t;\n          break;\n        }\n      }\n      \n      if (!transceiver) {\n        throw new Error(\"no correspond transceiver:\" + this.path);\n      }\n      \n      console.log(\"found transceiver for\", this.path, transceiver);\n      transceiver.direction = \"sendonly\";\n      \n      if (this.kind === \"video\") {\n        const params = transceiver.sender.getParameters();\n        await transceiver.sender.setParameters(Object.assign(params, { encodings: this.encodings }));\n      }\n      \n      await transceiver.sender.replaceTrack(this.track);\n      this.transceiver = transceiver;\n    } else {\n      if (this.track.kind === \"video\") {\n        this.transceiver = pc.addTransceiver(\n          this.track,\n          { direction: 'sendonly', sendEncodings: this.encodings, streams: [this.stream!] }\n        );\n      } else if (this.track.kind === \"audio\") {\n        this.transceiver = pc.addTransceiver(\n          this.track,\n          { direction: 'sendonly', streams: [this.stream!] }\n        );\n      } else {\n        throw new Error(`invalid track kind ${this.track.kind}`);\n      }\n    }\n  }\n\n  async close(pc: RTCPeerConnection, force?: boolean): Promise<void> {\n    if (this.track) {\n      this.onclose?.(this);\n      \n      // once track is stopped, it cannot be reused for receiver at least in chrome browser.\n      // for unknown reason (might be bug), \n      // if track is stopped, ontrack event of corresponding SDP media section always contains old 'readyState=ended' track.\n      // even if chrome statistics shows that track is active again (even with different ssrc)\n      // the reason I think this might be bug, \n      // is that track id does not change regardless SDP sends different msid for corresponding media section.\n      // for workaround, we do not stop track for receiver.\n      // QRPClient.close call the function with force = true, so that we can stop track for receiver for cleanup case.\n      if (force || !this.isReceiver) {\n        if (this.transceiver?.mid) {\n          pc.removeTrack(this.transceiver.sender);\n        }\n        this.track.stop();\n      }\n      \n      this.track = null;\n      this.transceiver = null;\n      this.stream = null;\n      this.opened = false;\n      this.pausedReasons = [];\n    }\n    this.media.removeTrack(this);\n  }\n}\n", "import { QRPClient } from './client.js';\nimport type { QRPCMediaInitOptions } from './types.js';\nimport { QRPCTrack } from './track.js';\n\nexport class QRPCMedia {\n  public readonly path: string;\n  public readonly direction: string;\n  public readonly initOptions: QRPCMediaInitOptions;\n  public readonly tracks: Record<string, QRPCTrack> = {};\n  public nextReconnect: number = 0;\n  public lastPing: number;\n  public reconnectIntervalMS: number | null = null;\n  public opened: boolean = true;\n\n  constructor(path: string, direction: string, initOptions?: QRPCMediaInitOptions) {\n    this.path = path;\n    this.direction = direction;\n    this.initOptions = initOptions || {};\n    this.lastPing = new Date().getTime();\n    this.keepAlive();\n  }\n\n  get isReceiver(): boolean {\n    return this.direction === \"recv\";\n  }\n\n  keepAlive(): void {\n    this.lastPing = new Date().getTime();\n  }\n\n  addTrack(t: QRPCTrack): void {\n    this.tracks[t.path] = t;\n  }\n\n  removeTrack(t: QRPCTrack): void {\n    delete this.tracks[t.path];\n  }\n\n  pause(reason: string): number | undefined {\n    const ret: number[] = [];\n    for (const k in this.tracks) {\n      const reconnectionWaitMS = this.tracks[k].pause(reason);\n      if (reason === QRPCTrack.PAUSE_REASON.remote_close) {\n        let waitMS: number | null = null;\n        if (!reconnectionWaitMS && reconnectionWaitMS !== false && reconnectionWaitMS !== null) {\n          waitMS = QRPCTrack.DEFAULT_TRACK_RECONNECTION_WAIT_MS;\n        } else if (typeof reconnectionWaitMS === \"number\") {\n          waitMS = reconnectionWaitMS;\n        }\n        if (waitMS) {\n          ret.push(waitMS);\n        }\n      }\n    }\n    if (ret.length > 0) {\n      // sort by ascending order and return first element (that is, minimum element)\n      return ret.sort()[0];\n    }\n  }\n\n  resume(reason: string): void {\n    for (const k in this.tracks) {\n      this.tracks[k].resume(reason);\n    }\n  }\n\n  startReconnect(c: QRPClient, backoffMS: number): void {\n    this.reconnectIntervalMS = backoffMS;\n    this.nextReconnect = new Date().getTime() + this.reconnectIntervalMS;\n    this.reconnect(c);\n  }\n\n  stopReconnect(): void {\n    this.reconnectIntervalMS = null;\n    this.nextReconnect = 0;\n  }\n\n  async reconnect(c: QRPClient): Promise<void> {\n    try {\n      console.log(`try reconnect for ${this.path}`);\n      await c.watchMedia(this.path, {\n        onopen: () => {},\n        onclose: () => {},\n        initOptions: Object.assign(this.initOptions, { sync: true })\n      });\n    } catch (e) {\n      console.log(`reconnect failed for ${this.path}`, e);\n    }\n  }\n}\n", "import type {\n  QRPCMediaSenderParams, QRPCMediaReceiverParams, QRPCMediaInitOptions,\n  QRPCStreamParams, QRPCStreamHandler, \n  QRPCMidMediaPathMap, QRPCSyscallArgs, QRPCPromiseCallbacks,\n} from './types.js';\nimport { QRPCTrack } from './track.js';\nimport { QRPCMedia } from './media.js';\n\nexport class QRPClient {\n  static readonly SYSCALL_STREAM = \"$syscall\";\n  static readonly DEFAULT_SCALABILITY_MODE = \"L1T3\";\n  static readonly NO_INPUT_THRESHOLD = 3;\n  static readonly VERBOSE_SYSCALL = [\"ping\", \"ping_ack\"];\n  static readonly MAX_MSGID = Number.MAX_SAFE_INTEGER;\n\n  public readonly url: string;\n  public readonly cname: string;\n  public cert: RTCCertificate | null = null;\n  public reconnect: number = 0;\n  public id: string | null = null;\n  public context: any = null;\n  public pc: RTCPeerConnection | null = null;\n  public syscall_ready: boolean = false;\n  public sentTracks: QRPCTrack[] = [];\n  public midMediaPathMap: QRPCMidMediaPathMap = {};\n  public rpcPromises: { [msgid: number]: QRPCPromiseCallbacks } = {};\n  public sdpGen: number = 0;\n  public msgidSeed: number = 1;\n  public syscallStream: RTCDataChannel | null = null;\n  public timer: ReturnType<typeof setInterval> | null = null;\n  public sdpQueue: any[] = [];\n  public streams: { [path: string]: RTCDataChannel } = {};\n  public medias: { [path: string]: QRPCMedia } = {};\n  public tracks: { [path: string]: QRPCTrack } = {};\n  public iceUsername: string | null = null;\n  public icePassword: string | null = null;\n  public candidates: RTCIceCandidate[] = [];\n  public endOfcandidates: boolean = false;\n  public onopen?: () => any;\n  public onclose?: () => number;\n  public onstream?: (c: RTCDataChannel) => QRPCStreamHandler;\n\n  constructor(url: string, cname?: string) {\n    this.url = url;\n    this.cname = cname || this.#genCN();\n    console.log(\"QRPClient\", this.cname, url);\n    this.#clear();\n  }\n\n  async #syscallMessageHandler(s: RTCDataChannel, event: MessageEvent): Promise<void> {\n    const data = JSON.parse(event.data);\n    if (QRPClient.VERBOSE_SYSCALL.indexOf(data.fn) < 0) {\n      console.log(\"syscall\", data);\n    }\n    if (!data.msgid) {\n      if (data.fn === \"close\") {\n        console.log(\"shutdown by server\");\n        this.#close();\n      } else if (data.fn === \"close_track\") {\n        console.log(\"close_track\", data.args.path);\n        await this.#closeTracks([data.args.path]);\n      } else if (data.fn == \"remote_pause\" || data.fn == \"remote_resume\") {\n        const t = this.tracks[data.args.path];\n        if (t) {\n          if (data.fn == \"remote_pause\") {\n            t.pause(QRPCTrack.PAUSE_REASON.remote_op);\n          } else {\n            t.resume(QRPCTrack.PAUSE_REASON.remote_op);\n          }\n        } else {\n          throw new Error(`no such track for ${data.fn}: ${data.args.path}`);\n        }\n      } else if (data.fn == \"ping\") {\n        if (data.args.path) {\n          const t = this.tracks[data.args.path];\n          if (t && t.media) {\n            t.media.keepAlive();\n          }\n        }\n      } else {\n        console.log(\"unhandled server syscall\", data);\n      }\n      return;\n    }\n\n    const promise = this.#fetchPromise(data.msgid);\n    if (!promise) {\n      console.log(\"no promise for msgid\", data.msgid);\n      return;\n    }\n    if (data.args && data.args.error) {\n      promise.reject(new Error(data.args.error));\n      return;\n    }\n    if (data.fn == \"consume\") {\n      throw new Error(\"currently, publish to other peer is not suported\");\n    } else if (data.fn == \"consume_ack\") {\n      if (!data.args.sdp) {\n        promise.reject(new Error(`invalid response: no sdp: ${JSON.stringify(data.args)}`));\n        return;\n      }\n      for (const k in data.args.status_map || {}) {\n        const st = data.args.status_map[k];\n        const t = this.tracks[k];\n        if (t) {\n          for (const r of st.pausedReasons || []) {\n            t.pause(r, true);\n          }\n        } else {\n          console.log(`no such track for [${k}]`, this.tracks, this.tracks[k]);\n        }\n      }\n      Object.assign(this.midMediaPathMap, data.args.mid_media_path_map || {});\n      console.log(\"midMediaPathMap => \", this.midMediaPathMap);\n      promise.resolve(data.args.sdp);\n    } else if (data.fn == \"produce\") {\n      throw new Error(\"currently, publish to other peer is not suported\");\n    } else if (data.fn == \"produce_ack\") {\n      if (!data.args.sdp) {\n        promise.reject(new Error(`invalid response: no sdp: ${JSON.stringify(data.args)}`));\n        return;\n      }\n      Object.assign(this.midMediaPathMap, data.args.mid_media_path_map || {});\n      console.log(\"midMediaPathMap => \", this.midMediaPathMap);\n      for (const k in data.args.status_map || {}) {\n        const st = data.args.status_map[k];\n        const t = this.tracks[k];\n        if (t) {\n          for (const r of st.pausedReasons || []) {\n            t.pause(r, true);\n          }\n        }\n      }\n      promise.resolve(data.args.sdp);\n    } else if (data.fn == \"close_media_ack\") {\n      await this.#closeTracks(data.args.paths);\n      promise.resolve(data.args.sdp);\n    } else if (\n      data.fn == \"resume_ack\" || data.fn == \"pause_ack\" || data.fn == \"close_ack\" ||\n      data.fn == \"sync_ack\" || data.fn == \"ping_ack\" || data.fn == \"publish_stream_ack\" ||\n      data.fn == \"remote_answer_ack\"\n    ) {\n      promise.resolve();\n    } else {\n      console.log(\"unknown syscall\", data);\n    }\n  }\n  #genCN(): string {\n    const bytes = new Uint8Array(8);\n    crypto.getRandomValues(bytes);\n    return btoa(String.fromCharCode(...bytes))\n      // make result url safe\n      .replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n  }\n  #clear(): void {\n    this.streams = {};\n    this.medias = {};\n    this.tracks = {};\n    this.syscall_ready = false;\n    // we use array to keep sent track add order.\n    // it is important to match them with SDP media section order\n    this.sentTracks = []; \n    this.midMediaPathMap = {};\n    this.rpcPromises = {};\n    this.sdpGen = 0;\n    this.msgidSeed = 1;\n    this.id = null;\n    this.syscallStream = null;\n    this.timer = null;\n    this.sdpQueue = [];\n  }\n\n  initIce(): void {\n    //Ice properties\n    this.iceUsername = null;\n    this.icePassword = null;\n    //Pending candidadtes\n    this.candidates = [];\n    this.endOfcandidates = false;\n  }\n\n  #newMsgId(): number {\n    if (this.msgidSeed >= QRPClient.MAX_MSGID) {\n      this.msgidSeed = 1;\n    }\n    return this.msgidSeed++;\n  }\n\n  #fetchPromise(msgid: number): QRPCPromiseCallbacks | null {\n    const p = this.rpcPromises[msgid];\n    if (p) {\n      delete this.rpcPromises[msgid];\n    }\n    return p;\n  }\n\n  #handshaked(): boolean {\n    return this.syscall_ready && this.pc !== null && this.pc.connectionState !== \"failed\";\n  }\n\n  #incSdpGen(): number {\n    return ++this.sdpGen;\n  }\n\n  get connected() {\n    return this.pc?.connectionState === \"connected\";\n  }\n\n  async connect(): Promise<void> {\n    //If already publishing\n    if (this.pc) {\n      console.log(\"Already connected\");\n      return;\n    }\n    // create dummy peer connection to generate sdp\n    const pc = await this.#createPeerConnection();\n    // Store pc object and token\n    this.pc = pc;\n    this.initIce();\n    this.#setupCallbacks(pc);\n    await this.#handshake();\n  }\n\n  async #createPeerConnection(): Promise<RTCPeerConnection> {\n    if (!this.cert) {\n      this.cert = await RTCPeerConnection.generateCertificate({\n        name: 'ECDSA',\n        namedCurve: 'P-256'\n      } as EcKeyGenParams);\n    }\n    // always uses same cert for peer connection\n    return new RTCPeerConnection({\n      iceServers: [],\n      certificates: [this.cert]\n    });\n  }\n\n  #setupCallbacks(pc: RTCPeerConnection): void {\n    // Listen for data channels\n    pc.ondatachannel = (event) => {       \n      const s = event.channel;\n      const path = s.label;\n      console.log(`accept stream ${path}`);\n      if (!this.onstream) {\n        s.close();\n        throw new Error(\"QRPClient.onstream is mandatory\");\n      }\n      const h = this.onstream(s);\n      if (!h) {\n        console.log(`No stream callbacks for path [${path}]`);\n        s.close();\n        return;\n      }\n      this.#setupStream(s, h);\n    }\n\n    // Listen addition of media tracks\n    pc.ontrack = async (event) => {\n      console.log(\"ontrack\", event);\n      const track = event.track;\n      const tid = track.id;\n      const receiver = event.receiver;\n      let path = undefined;\n      if (event.transceiver) {\n        if (event.transceiver.mid === \"probator\") { return; }\n        if (!event.transceiver.mid) {\n          throw new Error(`transceiver has no mid: ${event.transceiver}`);\n        }\n        path = this.midMediaPathMap[event.transceiver.mid];\n        if (!path) {\n          throw new Error(`No path is defined for mid = ${event.transceiver.mid}`);\n        }\n      } else {\n        throw new Error(\"event has no transceiver\");\n      }\n      let t = this.tracks[path];\n      if (!t) {\n        console.log(`No media for path ${path}`);\n        track.stop();\n        return;\n      }\n      if (t.direction === \"recv\") {\n        t.track = track;\n        t.transceiver = event.transceiver;\n        t.stream = event.streams[0];\n      }\n      if (!t.opened) {\n        if (t.onopen) {\n          const r = await Promise.resolve(t.onopen(t));\n          if (r === false || r === null) {\n            console.log(`close media by application ${path}`);\n            this.closeMedia(path);\n            return;\n          }\n        }\n        t.opened = true;\n      }\n    }\n    \n    // Listen for state change events\n    pc.oniceconnectionstatechange = (event) => {\n      console.log(\"ICE connection state change\", pc.iceConnectionState);\n    }\n    pc.onconnectionstatechange = async (event) =>{\n      console.log(\"Connection state change\", pc.connectionState);\n      switch(pc.connectionState) {\n        case \"connected\":\n          // The connection has become fully connected\n          break;\n        case \"disconnected\":\n        case \"failed\":\n          // One or more transports has terminated unexpectedly or in an error\n          await this.#close();\n          break;\n        case \"closed\":\n          // The connection has been closed\n          break;\n      }\n    }\n\n    // Listen for candidates\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        // Ignore candidates not from the first m line\n        if ((event.candidate.sdpMLineIndex || 0) >0) {\n          return;\n        }\n        this.candidates.push(event.candidate);                                         \n      } else {\n        // No more candidates\n        this.endOfcandidates = true;\n      }\n    }\n    this.timer = setInterval(() => {\n      const now = (new Date()).getTime();\n      this.#checkMedias(now);\n    }, 1000); // 1\u79D2\u3054\u3068\u306B\u30C1\u30A7\u30C3\u30AF\n  }  \n\n  parseLocalOffer(localOffer: string) {\n    const result: { [mid: string]: { [ssrc: string]: string[] } } = {};\n    let currentMid: string | undefined = undefined;\n    let currentSsrcs : { [ssrc: string]: string[] } = {};\n    const lines = localOffer.split(/\\r?\\n/);\n    lines.push(\"m=dummy\"); // ensure last section processed\n    for (const l of lines) {\n      if (l.startsWith(\"m=\")) {\n        currentMid = undefined;\n        currentSsrcs = {};\n      } else if (l.startsWith(\"a=mid:\")) {\n        if (!currentMid) {\n          // a=mid:$mid_value\n          currentMid = l.slice(6).trim();\n          result[currentMid] = currentSsrcs;\n        } else {\n          throw new Error(`invalid find a=mid line twice before reset by m= line ${currentMid},${l.slice(6)}`);\n        }\n      } else if (l.startsWith(\"a=ssrc:\")) {\n        //a=ssrc:$ssrc_value $attribute_name:$attribute_value\n        const parsed = l.slice(7).split(/\\s/,2);\n        const ssrc = parsed[0].trim();\n        const attrName = parsed[1].split(/:/, 1)[0].trim();\n        console.log(\"ssrc/attrName\", ssrc, attrName);\n        if (!currentSsrcs[ssrc]) {\n          currentSsrcs[ssrc] = [];\n        }\n        currentSsrcs[ssrc].push(attrName);\n        if (currentMid) {\n          result[currentMid] = currentSsrcs;\n        }\n      }\n    }\n    // result will be like { [mid]: { [ssrc]: [attr1, attr2, ...] } }\n    // filter element that has multiple ssrcs (dedupe lines with same ssrc), probably simulcast media section of firefox\n    return Object.fromEntries(\n      Object.entries(result).filter(v => Object.keys(v[1]).length == 1).map(v => [v[0], Object.keys(v[1])[0]])\n    );\n  }\n\n  #checkMedias(now: number): void {\n    let mediaOpened = false;\n    for (const k in this.medias) {\n      const m = this.medias[k];\n      if (m.isReceiver) {\n        // console.log(\"check track\", t.path, now - t.lastPing);\n        if (now - m.lastPing > (QRPClient.NO_INPUT_THRESHOLD * 1000)) {\n          if (m.opened) {\n            m.opened = false;\n            const reconnectionWaitMS = m.pause(QRPCTrack.PAUSE_REASON.remote_close);\n            console.log(`no ping for ${m.path} for ${QRPClient.NO_INPUT_THRESHOLD * 1000} ms`, reconnectionWaitMS);\n            if (reconnectionWaitMS) {\n              m.startReconnect(this, reconnectionWaitMS);\n              console.log(`track ${m.path} will try reconnect every ${reconnectionWaitMS} ms`);\n            }\n          } else if (m.reconnectIntervalMS && now > m.nextReconnect) {\n            m.reconnect(this);\n            m.nextReconnect = now + m.reconnectIntervalMS;\n          }\n        } else if (!m.opened) {\n          console.log(`input again for ${m.path}`);\n          m.opened = true;\n          m.stopReconnect();\n          m.resume(QRPCTrack.PAUSE_REASON.remote_close);\n        }\n      } else if (m.opened) {\n        mediaOpened = true;\n      }\n    }\n    if (mediaOpened) {\n      this.syscall(\"ping\", {});\n    }\n  }\n\n  async #createOffer(tracks: QRPCTrack[]): Promise<{\n    localOffer: RTCSessionDescriptionInit, midPathMap: { [mid: string]: string }\n  }> {\n    const midPathMap: { [mid: string]: string } = {};\n    // create dummy peer connection to generate sdp\n    const pc = await this.#createPeerConnection();\n    // emurate creating stream to generate correct sdp\n    pc.createDataChannel(\"dummy\");\n    for (const t of tracks) {\n      await t.open(pc);\n    }\n    const localOffer = await pc.createOffer();\n    await pc.setLocalDescription(localOffer);\n    const midSsrcMap = this.parseLocalOffer(localOffer.sdp!);\n    // console.log(\"midSsrcMap\", midSsrcMap);\n    for (const t of tracks) {\n      // now, mid is decided by calling pc.setLocalDescription. \n      // mid (in server-responded remote offer) probably changes \n      // after it processes on server side, but because of client mid actually decided\n      // by server remote offer, changes causes no problem.\n      midPathMap[t.mid!] = t.path;\n      t.ssrc = midSsrcMap[t.mid!] || undefined;\n      // console.log(`${t.path},mid=${t.mid} ssrc = ${t.ssrc}`);\n    }\n    pc.close();\n    return {localOffer, midPathMap};\n  }\n\n  #fixupLocalAnswer(localAnswer: string, midSsrcMap: { [mid: string]: string }): string {\n    // console.log(\"#fixupLocalAnswer\", midSsrcMap);\n    const chunks = [];\n    let chunk: string[] = [];\n    const lines = localAnswer.split(/\\r?\\n/);\n    lines.push(\"m=dummy\"); // ensure last section processed\n    let currentMid;\n    for (const l of lines) {\n      if (l.startsWith(\"m=\")) {\n        if (!currentMid) {\n          if (chunks.length > 0) {\n            throw new Error(`only first chunk allowed without mid`);\n          }\n          chunks.push({mid: null, chunk});\n        } else {\n          if (chunk.length <= 0) {\n            throw new Error(`should have chunk for ${currentMid}`);\n          }\n          chunks.push({mid: currentMid, chunk});\n        }\n        chunk = [l];\n        currentMid = undefined;\n        continue;\n      }\n      chunk.push(l);\n      if (l.startsWith(\"a=mid:\")) {\n        if (!currentMid) {\n          // a=mid:$mid_value\n          currentMid = l.slice(6);\n        } else {\n          throw new Error(`invalid find a=mid line twice before reset by m= line ${currentMid},${l}`);\n        }\n      }\n    }\n    const sdp = [];\n    for (const c of chunks) {\n      const ssrc = c.mid !== null ? midSsrcMap[c.mid] : null;\n      if (ssrc) {\n        const text = c.chunk.join(\"\\n\");\n        sdp.push(text.replace(/a=ssrc:[0-9]+/g, `a=ssrc:${ssrc}`));\n      } else {\n        sdp.push(c.chunk.join(\"\\n\"));\n      }\n    }\n    return sdp.join(\"\\n\");\n  }\n\n  async #setRemoteOffer(remoteOffer: string, sdpGen: number, sentTracks: QRPCTrack[]): Promise<void> {\n    console.log(\"remote offer sdp\", remoteOffer, sdpGen);\n    if (this.pc == null) {\n      throw new Error(\"peer connection is not initialized\");\n    }\n    // if there is sdp which generation is later than current sdpGen, the generation is skipped\n    for (const e of this.sdpQueue) {  \n      if (e.sdpGen > sdpGen) {\n        console.log(`skip sdpGen=${sdpGen} because newer generation exists: ${e.sdpGen}`);\n        return;\n      }\n    }\n    this.sdpQueue.push({remoteOffer, sdpGen, sentTracks});\n    if (this.sdpQueue.length > 1) {\n      console.log(`queue sdpGen=${sdpGen}`, this.sdpQueue);\n      return;\n    }\n    // set remote description\n    await this.pc.setRemoteDescription({type:\"offer\",sdp:remoteOffer});\n    // set tracks to actual peer connection\n    const midSsrcMap: { [mid: string]: string } = {};\n    for (const t of sentTracks) {\n      await t.open(this.pc, this.midMediaPathMap);\n      if (t.ssrc) {\n        midSsrcMap[t.mid!] = t.ssrc;\n      }\n    }\n    const answer = await this.pc.createAnswer();\n    // answer.sdp = this.#fixupLocalAnswer(answer.sdp, midSsrcMap);\n    // console.log(\"local answer sdp\", answer.sdp);\n    if (this.#handshaked()) {\n      const newMidSsrcMap = this.parseLocalOffer(answer.sdp!);\n      console.log(\"midSsrcMaps\", midSsrcMap, newMidSsrcMap);\n      await this.syscall(\"remote_answer\", {\n        midMap: Object.fromEntries(\n          Object.keys(midSsrcMap).map(k => [k, {\n            ssrc_fixups:[[Number(midSsrcMap[k]),Number(newMidSsrcMap[k])]]\n          }])\n        ),\n      });\n      // update ssrc of tracks\n      for (const t of sentTracks) {\n        t.ssrc = newMidSsrcMap[t.mid!] || undefined;\n      }\n    }\n    await this.pc.setLocalDescription(answer);\n    console.log(`apply sdpGen=${sdpGen} is finished`);\n    if (this.sdpQueue.length > 1) {\n      // async sleep to stabilize frequent sdp update\n      await new Promise(r => setTimeout(r, 1000)); // this may add more sdp to the queue\n      // fetch last element of the queue and execute.\n      const e = this.sdpQueue[this.sdpQueue.length - 1];\n      // by above filtering, elements in the queue has sdpGen value with ascending order.\n      this.sdpQueue = []; // clear queue (because non-last element should be outdated and can ignore)\n      // so that e should never be queued again.\n      await this.#setRemoteOffer(e.remoteOffer, e.sdpGen, e.sentTracks); // during this call, sdpQueue may be filled again\n    } else {\n      this.sdpQueue = [];\n    }\n  }\n\n  async #capability() {\n    const pc = new RTCPeerConnection();\n    pc.addTransceiver(\"audio\");\n    pc.addTransceiver(\"video\");\n    const offer = await pc.createOffer({offerToReceiveAudio: true, offerToReceiveVideo: true});\n    // console.log(\"capability sdp\", offer.sdp);\n    return offer.sdp;\n  }\n  async #handshake() {\n    if (this.#handshaked()) {\n      throw new Error(\"handshake only called once in a session\");\n    }\n    // generate syscall stream (it also ensures that SDP for data channel is generated)\n    const syscallReady = new Promise((resolve, reject) => {\n      this.syscallStream = this.openStream(QRPClient.SYSCALL_STREAM, {\n        onmessage: this.#syscallMessageHandler.bind(this),\n        onopen: (s, e) => resolve(e), onerror: (s, e) => reject(e)\n      });\n    });\n    const sdpGen = this.#incSdpGen();\n    const sentTracks = [...this.sentTracks];\n    // Create new SDP offer without initializing actual peer connection\n    const {localOffer} = await this.#createOffer(sentTracks);\n    console.log(\"local offer sdp\", localOffer.sdp);\n\n    //store local ice ufrag/pwd\n    this.iceUsername = localOffer.sdp!.match(/a=ice-ufrag:(.*)[\\r\\n]+/)![1];\n    this.icePassword = localOffer.sdp!.match(/a=ice-pwd:(.*)[\\r\\n]+/)![1];\n\n    //Do the post request to the WHIP endpoint with the SDP offer\n    const fetched = await fetch(this.url, {\n      method: \"POST\",\n      body: JSON.stringify({\n        sdp:localOffer.sdp,\n        cname:this.cname,\n        capability: await this.#capability()\n      }),\n      headers: {\n        \"Content-Type\": \"application/json\"\n      }\n    });\n    if (!fetched.ok) {\n      throw new Error(`Request rejected with status ${fetched.status}`);\n    }\n\n    //Get the SDP answer\n    let text = undefined;\n    try {\n      text = await fetched.text();\n      const {sdp: remoteOffer, mid_media_path_map: midMediaPathMap} = JSON.parse(text);\n      for (const k in midMediaPathMap || {}) {\n        this.midMediaPathMap[k] = midMediaPathMap[k];\n      }\n      console.log(\"midMediaPathMap =>\", this.midMediaPathMap);\n\n      this.id = remoteOffer.match(/a=ice-ufrag:(.*)[\\r\\n]+/)[1];\n      console.log(\"id\", this.id);\n\n      await this.#setRemoteOffer(remoteOffer, sdpGen, sentTracks);\n      await syscallReady;\n      this.syscall_ready = true;\n      if (this.onopen) {\n        this.context = await this.onopen();\n      }  \n    } catch (e) {\n      console.log(`error in handling whip response: ${e}|${text || \"no response\"}`);\n      throw e;\n    }\n  }\n  async close(): Promise<void> {\n    await this.#close(true);\n  }\n\n  async #close(fromLocal?: boolean): Promise<void> {\n    if (!this.pc) {\n      // Already stopped\n      return\n    }\n    if (fromLocal) {\n      // send close notify to server\n      await this.syscall(\"close\", {});\n    }\n    let reconnectionWaitMS;\n    if (this.onclose) {\n      reconnectionWaitMS = this.onclose();\n      if (!reconnectionWaitMS) {\n        reconnectionWaitMS = 0; \n      } else {\n        // nsec to msec\n        reconnectionWaitMS = reconnectionWaitMS / 1000 / 1000;\n      }\n    } else {\n      // default 5 sec (TODO: configurable)\n      reconnectionWaitMS = 5000;\n    }\n    for (const k in this.tracks) {\n      console.log(\"close track\", k); \n      await this.tracks[k].close(this.pc, true); // trur for closing receivers\n    }\n    for (const k in this.streams) {\n      console.log(\"close stream\", k);\n      this.streams[k].close();\n    }\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n    if (this.pc.connectionState != \"failed\") {\n      this.pc.close();\n    }\n    this.pc = null;\n    this.#clear();\n    if (reconnectionWaitMS > 0) {\n      console.log(`attempt reconnect after ${reconnectionWaitMS} ms`);\n      setTimeout(() => {\n        this.reconnect++;\n        this.connect();\n      }, reconnectionWaitMS);\n    } else {\n      console.log(\"no reconnect. bye!\");\n    }\n  }\n\n  #canonicalOpenPath(path: string): string {\n    const parsed = path.split('/');\n    if (parsed.length == 1) {\n      return path + \"/\";\n    } else {\n      if (parsed[parsed.length - 1].length > 0) {\n        throw new Error(`invalid path: ${path}: should be ended with /`);\n      }\n      return path;\n    }\n  }\n\n  async openMedia(path: string, params: QRPCMediaSenderParams): Promise<QRPCTrack[]> {\n    const {stream, encodings, onopen, onclose, onupdate, onpause, onresume, initOptions} = params;\n    const cpath = this.#canonicalOpenPath(path);\n    console.log(\"openMedia\", cpath, stream, encodings);\n    if (!encodings) { throw new Error(\"encodings is mandatory\"); }\n    if (encodings.length > 3) { throw new Error(\"encodings more than 3 may not be treated correctly\"); }\n    const ridScalabilityModeMap: {[rid: string]: string} = {};\n    let index = 0;\n    encodings.forEach(e => {\n      if (!e.maxBitrate) { throw new Error(\"for each encodings, maxBitrate is mandatory\"); }\n      if (e.rid) { throw new Error(`cannot specify rid for encodings`); }\n      e.rid = `r${index++}`;\n      e.scalabilityMode = e.scalabilityMode || QRPClient.DEFAULT_SCALABILITY_MODE;\n      ridScalabilityModeMap[e.rid] = e.scalabilityMode;\n    });\n    // sort by maxBitrate asc, because server regards earlier encoding as lower quality,\n    // regardless its actual bitrate\n    encodings.sort((a, b) => a.maxBitrate! - b.maxBitrate!);\n    const tracks: QRPCTrack[] = [];\n    stream.getTracks().forEach(t => {\n      const path = QRPCTrack.path(cpath, t.kind);\n      const media = this.#addMedia(cpath, \"send\", initOptions);\n      const track = new QRPCTrack(path, media, stream, t, encodings, {\n        onopen, onclose, onupdate, onpause, onresume\n      });\n      // console.log(\"openMedia: add track for\", track.path);\n      this.tracks[track.path] = track;\n      this.sentTracks.push(track);\n      tracks.push(track);\n    });\n    if (this.#handshaked()) {\n      // already handshaked, so renegotiate for newly produced tracks.\n      const {localOffer, midPathMap} = await this.#createOffer(tracks);\n      console.log(\"openMedia: local offer\", localOffer.sdp, midPathMap);\n      const sdpGen = this.#incSdpGen();\n      const sentTracks = [...this.sentTracks];\n      try {\n        const remoteOffer = await this.syscall(\"produce\", {\n          sdp: localOffer.sdp, initOptions, midPathMap, rtp: {ridScalabilityModeMap}\n        });\n        await this.#setRemoteOffer(remoteOffer, sdpGen, sentTracks);\n      } catch (e) {\n        console.log(`openMedia: remote negotiation failed: ${e}`);\n        for (const t of tracks) {\n          delete this.medias[t.media.path];\n          delete this.tracks[t.path];\n          await t.close(this.pc!);\n        }\n        throw e;\n      }\n    }\n    return tracks;\n  }\n\n  #addMedia(path: string, direction: string, initOptions?: QRPCMediaInitOptions): QRPCMedia {\n    // 1. path/(video|audio) => path/\n    // 2. path/ => path/\n    const parsed = path.split(\"/\");\n    let media;\n    if (parsed[parsed.length - 1] === \"video\" || parsed[parsed.length - 1] === \"audio\") {\n      path = path.slice(0, -5);\n    }\n    if (this.medias[path]) {\n      media = this.medias[path];\n    } else {\n      media = new QRPCMedia(path, direction, initOptions);\n      this.medias[path] = media;\n    }\n    return media;\n  }\n\n  // media_path is one of the following:\n  // 1. ${cname}/${local_path}/ => all media kind under local_path consumed\n  // 2. ${cname}/${local_path}/${media_kind} => only media_kind under local_path consumed\n  // for 1. last / is mandatory to indicate that it is a directory.\n  // but / can be omitted if last component of local_path does not ssem to be a media kind (not audio/video)\n  #canonicalViewPath(path: string): {cpath: string, kind: string | undefined} {\n    const parsed = path.split('/');\n    if (parsed.length < 2) {\n      throw new Error(`invalid path: ${path}: at least \\${cname}/\\${single_component_local_path} required`);\n    } else if (parsed.length == 2) {\n      const last_component = parsed[parsed.length - 1];\n      if (last_component === \"audio\" || last_component === \"video\") {\n        throw new Error(`invalid path: ${path}: has single component local_path but the component seems to be media kind`);\n      }\n      return { cpath: path + \"/\", kind: undefined };\n    } else {\n      const last_component = parsed[parsed.length - 1];\n      if (last_component.length > 0) {\n        if (last_component !== \"audio\" && last_component !== \"video\") {\n          return { cpath: path + \"/\", kind: undefined };\n        }\n        return {cpath: path, kind: last_component};\n      }\n      return { cpath: path, kind: undefined };\n    }\n  }\n\n  async watchMedia(path: string, params: QRPCMediaReceiverParams): Promise<QRPCTrack[]> {\n    const {onopen, onclose, onpause, onresume, initOptions} = params;\n    if (!this.#handshaked()) {\n      throw new Error(\"watchMedia can only be called after handshake\");\n    }\n    const {cpath, kind} = this.#canonicalViewPath(path);\n    const tracks = [];\n    for (const k of (kind ? [kind] : [\"video\", \"audio\"])) {\n      const path = kind ? cpath : QRPCTrack.path(cpath, k);\n      const media = this.#addMedia(cpath, \"recv\", initOptions);\n      let track = this.tracks[path];\n      if (!track) {\n        if (initOptions?.sync) { throw new Error(`no track for ${path} yet but sync option is set`); }\n        track = new QRPCTrack(path, media, null, null, [], {\n          onopen, onclose, onpause, onresume\n        });\n        // console.log(\"watchMedia: add track for\", path);\n        this.tracks[path] = track;\n      }\n      tracks.push(track);\n    }\n    // sdpGen/sentTracks/remoteOffer should be timing matched. otherwise other media API call\n    // may change sdpGen/sentTracks which does not match with current values\n    // same as sdpGen/sentTrack in openMedia, #handshake\n    const sdpGen = this.#incSdpGen();\n    const sentTracks = [...this.sentTracks];\n    try {\n      const remoteOffer = await this.syscall(\"consume\", {path: cpath, initOptions});\n      await this.#setRemoteOffer(remoteOffer, sdpGen, sentTracks);\n    } catch (e) {\n      console.log(\"watchMedia: remote negotiation failed\", e);\n      for (const t of tracks) {\n        delete this.medias[t.media.path];\n        delete this.tracks[t.path];\n        await t.close(this.pc!);\n      }\n      throw e;\n    }\n    return tracks;\n  }\n\n  async pauseMedia(path: string): Promise<void> {\n    const t = this.tracks[path];\n    if (t) {\n      await this.syscall(\"pause\", { path });\n    } else {\n      throw new Error(\"pauseMedia: no media for \" + path);\n    }\n  }\n\n  async resumeMedia(path: string): Promise<void> {\n    const t = this.tracks[path];\n    if (t) {\n      await this.syscall(\"resume\", { path });\n    } else {\n      throw new Error(\"resumeMedia: no media for \" + path);\n    }\n  }\n\n  async updateMedia(path: string, options: {stream: MediaStream}): Promise<QRPCTrack[]> {\n    const {stream} = options;\n    const cpath = this.#canonicalOpenPath(path);\n    const m = this.medias[cpath];\n    if (!m) {\n      throw new Error(\"updateMedia: no media for \" + cpath);\n    }\n    \n    const tracks: QRPCTrack[] = [];\n    stream.getTracks().forEach(t => {\n      const track_path = QRPCTrack.path(cpath, t.kind);\n      const track = this.tracks[track_path];\n      if (track) {\n        track.update({stream, track: t});\n        tracks.push(track);\n      } else {\n        console.log(`no track for ${path}`);\n      }\n    });\n    \n    return tracks;\n  }\n\n  async #closeTracks(paths: string[]): Promise<void> {\n    const medias: {[path: string]: QRPCMedia} = {};\n    \n    for (const path of paths) {\n      const t = this.tracks[path];\n      if (t) {\n        medias[t.media.path] = t.media;\n        await t.close(this.pc!); // this removes the track from media.tracks\n        delete this.tracks[path];\n      }\n      const index = this.sentTracks.indexOf(t);\n      if (index >= 0) {\n        this.sentTracks.splice(index, 1);\n      }\n    }\n    // if media has no tracks, remove it too\n    for (const k in medias) {\n      const m = medias[k];\n      if (Object.keys(m.tracks).length === 0) {\n        console.log(\"close media\", m.path);\n        delete this.medias[m.path];\n      }\n    }\n  }\n\n  async closeMedia(path: string): Promise<void> {\n    const remoteOffer = await this.syscall(\"close_media\", { path });\n    const sdpGen = this.#incSdpGen();\n    const sentTracks = [...this.sentTracks];\n    await this.#setRemoteOffer(remoteOffer, sdpGen, sentTracks);\n  }\n\n  openStream(path: string, params: QRPCStreamParams): RTCDataChannel {\n    if (this.streams[path]) {\n      throw new Error(\"stream already exists for path: \" + path);\n    }\n    const s = this.pc!.createDataChannel(path, params as RTCDataChannelInit);\n    this.#setupStream(s, params);\n    return s;\n  }\n\n  closeStream(path: string): void {\n    const s = this.streams[path];\n    if (!s) {\n      console.log(`No stream for path ${path}`);\n      return;\n    }\n    s.close();\n    delete this.streams[path];\n  }\n\n  watchStream(path: string, options: QRPCStreamHandler): RTCDataChannel {\n    throw new Error(\"watchStream not implemented yet\");\n  }\n\n  async syscall(fn: string, args?: QRPCSyscallArgs): Promise<any> {\n    return new Promise((resolve, reject) => {\n      const msgid = this.#newMsgId();\n      this.syscallStream!.send(JSON.stringify({fn, args, msgid}));\n      this.rpcPromises[msgid] = { resolve, reject };\n    });\n  }\n\n  #setupStream(s: RTCDataChannel, h: QRPCStreamParams): void {\n    const path = s.label;\n    \n    s.onopen = (h.onopen && (async (event) => {\n      if (h.publish) { await this.syscall(\"publish_stream\",{path}); }\n      const ctx = h.onopen!(s, event);\n      if (ctx && typeof ctx === \"object\" && \"close\" in ctx) {\n        console.log(`close stream by application path=${path}`);\n        this.closeStream(path);\n      } else {\n        (s as any).context = ctx;\n      }\n    })) || (async (event) => {\n      if (h.publish) { await this.syscall(\"publish_stream\",{path}); }\n    });\n    \n    s.onclose = (h.onclose && ((event) => {\n      h.onclose!(s, event);\n      delete this.streams[path];\n    })) || ((event) => {\n      delete this.streams[path];\n    });\n    \n    s.onerror = (h.onerror && ((event) => {\n      h.onerror!(s, event);\n      delete this.streams[path];\n    })) || ((event) => {\n      delete this.streams[path];\n    });\n    \n    s.onmessage = (event) => h.onmessage(s, event);\n    \n    this.streams[path] = s;\n  }\n}\n"],
  "mappings": "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",
  "names": ["index_exports", "__export", "QRPCMedia", "QRPCTrack", "QRPClient", "promisify", "a", "QRPCTrack", "path", "media", "stream", "track", "encodings", "options", "__publicField", "canonical_path", "kind", "parsed", "reason", "noCallback", "promisify", "i", "update", "pc", "midMediaPathMap", "transceiver", "t", "params", "force", "QRPCMedia", "path", "direction", "initOptions", "__publicField", "t", "reason", "ret", "k", "reconnectionWaitMS", "QRPCTrack", "waitMS", "c", "backoffMS", "e", "_QRPClient_instances", "syscallMessageHandler_fn", "genCN_fn", "clear_fn", "newMsgId_fn", "fetchPromise_fn", "handshaked_fn", "incSdpGen_fn", "createPeerConnection_fn", "setupCallbacks_fn", "checkMedias_fn", "createOffer_fn", "fixupLocalAnswer_fn", "setRemoteOffer_fn", "capability_fn", "handshake_fn", "close_fn", "canonicalOpenPath_fn", "addMedia_fn", "canonicalViewPath_fn", "closeTracks_fn", "setupStream_fn", "_QRPClient", "url", "cname", "__privateAdd", "__publicField", "__privateMethod", "pc", "localOffer", "result", "currentMid", "currentSsrcs", "lines", "l", "parsed", "ssrc", "attrName", "v", "path", "params", "stream", "encodings", "onopen", "onclose", "onupdate", "onpause", "onresume", "initOptions", "cpath", "ridScalabilityModeMap", "index", "e", "a", "b", "tracks", "t", "QRPCTrack", "media", "track", "midPathMap", "sdpGen", "sentTracks", "remoteOffer", "kind", "k", "options", "track_path", "s", "fn", "args", "resolve", "reject", "msgid", "event", "data", "promise", "st", "r", "bytes", "p", "h", "tid", "receiver", "now", "mediaOpened", "m", "reconnectionWaitMS", "midSsrcMap", "localAnswer", "chunks", "chunk", "sdp", "c", "text", "answer", "newMidSsrcMap", "syscallReady", "fetched", "midMediaPathMap", "fromLocal", "direction", "QRPCMedia", "last_component", "paths", "medias", "ctx", "QRPClient"]
}
